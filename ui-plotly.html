<!--
  Copyright 2020 Paul Reed & Bart Butenaers
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<style>
    .plotly-trace-property-autocomplete {
        max-height: 100px;
        overflow-y: auto;
        overflow-x: hidden; /* prevent horizontal scrollbar */
        /*padding-right: 20px;/* add padding to account for vertical scrollbar */
    } 
</style>

<script type="text/javascript">
    const PLOTLY_ARRAY_PREFIX  = "#@array_name@#";
    const PLOTLY_BOOLEAN_TRUE  = "#@boolean_true@#";
    const PLOTLY_BOOLEAN_FALSE = "#@boolean_false@#";
    
    // Get an array of all attribute names (in dot notation for nested attributes) for the specified obj (i.e. trace)
    function getAttributeNames(obj, results, path) {
        const r = results;
        Object.keys(obj).forEach(function(key) {
            var subObj = obj[key];
            if(subObj && typeof subObj === 'object') {
                var newPath = new String(path);
                
                if (path != "") {
                    newPath += ".";
                }
                newPath += key;
                
                if(subObj.hasOwnProperty("valType")) {
                    results.push(newPath);
                }
                    
                getAttributeNames(subObj, results, newPath);
            }
        });
        return r;
    }
    
    // Get (nested) attribute of an object
    function getAttribute(obj, path) {
        var attribute = obj;
        var attributeNames = path.split(".");
        
        // Don't use forEach because then the return value isn't passed to Node-RED!
        for (var i = 0; i < attributeNames.length; i++) {
            var attributeName = attributeNames[i];
            attribute = attribute[attributeName];
            
            if (!attribute) {
                return null;
            }
        }
        
        return attribute;
    }
    
    // Get the trace row (from the editableList in the second tabsheet)
    function getTraceRow(traceName) {
        var result = null;
        
        var tracesList = $("#node-input-traces-container").editableList('items');
        tracesList.each(function(i) {
            var traceRow = $(this);
            if (traceRow.find(".node-input-trace-name").val() === traceName) {
                // The row itself is generated by Node-RED, as a wrapper around our DIV row.
                result = traceRow.find('.node-input-trace-div');
            }
        });
        
        return result;
    }
    
    // Get the array row (from the editableList in the fourth tabsheet)
    function getArrayRow(arrayName) {
        var result = null;
        
        var arrayList = $("#node-input-arrays-container").editableList('items');
        arrayList.each(function(i) {
            var arrayRow = $(this);
            if (arrayRow.find(".node-input-array-name").val() === arrayName) {
                // The row itself is generated by Node-RED, as a wrapper around our DIV row.
                result = arrayRow.find('.node-input-array-div');
            }
        });
        
        return result;
    }
    
    // Copy the trace properties (from the editableList in the third tabsheet) to the trace data (in the editableList in the second tabsheet)
    function copyTraceProperties(traceName) {
        var traceRow = getTraceRow(traceName);
        
        // Delete the old trace properties in the trace row ...
        traceRow.data('trace-properties', []);
    
        // Store the trace properties from the editableList into the trace row...
        var propertiesList = $("#node-input-properties-container").editableList('items');
        propertiesList.each(function(i) {
            var propertiesRow = $(this);

            var propertyNameField  = propertiesRow.find(".node-input-property-name");
            var propertyValueField = propertiesRow.find(".node-input-property-value");
            
            var propertyName  = propertyNameField.val();
            var propertyValue = propertyValueField.val();

            // A trace property of type 'flaglist' will be visualised as a multiselect dropdown.  However such a dropdown will
            // return the selected value as an array (e.g. ['a', 'b', 'c']), while Plotly needs it as a '+' separated string (e.g. "a+b+c").
            if (Array.isArray(propertyValue) && propertyValueField.is("select") && propertyValueField.prop('multiple')) {
                propertyValue = propertyValue.join('+');
            }
                
            var traceProperty = {
                name: propertyName,
                value: propertyValue
            }
            
            traceRow.data('trace-properties').push(traceProperty);
        });
    }
    
    // Copy the array items (from the editableList in the fifth tabsheet) to the array data (in the editableList in the fourth tabsheet)
    function copyArrayItems(arrayName) {
        var arrayRow = getArrayRow(arrayName);
        
        // Delete the old array items in the array row ...
        arrayRow.data('array-items', []);
    
        // Store the array items from the editableList into the array row...
        var itemsList = $("#node-input-items-container").editableList('items');
        itemsList.each(function(i) {
            var itemsRow = $(this);

            var itemValueField = itemsRow.find(".node-input-item-value");
            var itemValue = itemValueField.val();

            var arrayItem = {
                value: itemValue
            }
            
            arrayRow.data('array-items').push(arrayItem);
        });
    }
    
    function getArrayNames(arrayType) {
        var arrayNames = [];
        
        var arraysList = $("#node-input-arrays-container").editableList('items');
        arraysList.each(function(i) {
            var row = $(this);  
            var arrayName = row.find(".node-input-array-name").val();
            
            if (row.find(".node-input-array-type").val() === arrayType) {
                arrayNames.push(arrayName);
            }
        });
        
        return arrayNames;
    }
    
    // Show or hide tabsheets depending on the data in the other tabsheets.
    // Remark: it is not possible to disable tabsheets in Node-RED (see https://discourse.nodered.org/t/disable-a-tabsheet-in-config-screen)
    function setupTabsheets(node) {
        var tabsheets = [];
        
        tabsheets.push("node-plotly-tab-layout");
        
        
        tabsheets.push("node-plotly-tab-traces");
        
        // Only show the "Properties" tabsheet when there are traces available (on the "Traces" tabsheet)
        var tracesList = $("#node-input-traces-container").editableList('items');
        if (tracesList.length === 0) {
            if (node.tabs.contains("node-plotly-tab-traceproperties")) {
                node.tabs.removeTab("node-plotly-tab-traceproperties");
            }        
        }
        else {
            if (!node.tabs.contains("node-plotly-tab-traceproperties")) {
                node.tabs.addTab({
                    id: "node-plotly-tab-traceproperties",
                    label: "Properties"
                })
            }
            tabsheets.push("node-plotly-tab-traceproperties");
        }

        tabsheets.push("node-plotly-tab-arrays");
        
        // Only show the "Items" tabsheet when there are arrays available (on the "Array" tabsheet)
        var arraysList = $("#node-input-arrays-container").editableList('items');
        if (arraysList.length === 0) {
            if (node.tabs.contains("node-plotly-tab-arrayitems")) {
                node.tabs.removeTab("node-plotly-tab-arrayitems");
            }        
        }
        else {
            if (!node.tabs.contains("node-plotly-tab-arrayitems")) {
                node.tabs.addTab({
                    id: "node-plotly-tab-arrayitems",
                    label: "Properties"
                })
            }
            tabsheets.push("node-plotly-tab-arrayitems");
        }
        
        node.tabs.order(tabsheets);
    }
    
    function getFieldValues(fields) {
        var names = [];
        
        fields.each(function (i) {
            names.push(this.value);
        });
        
        return names;
    }
    
    function validateTraceName(traceName, traceNames) {
        if (!traceName || traceName === "") {
            return false; // Empty value
        }
        
        if (traceNames.indexOf(traceName) !== traceNames.lastIndexOf(traceName)) {
            return false; // Duplicate value
        }
        
        return true;
    }
    
    function validatePropertyName(propertyName, propertyNames, attributes) {
        if (!propertyName || propertyName === "") {
            return false; // Empty value
        }
        
        if (propertyNames.indexOf(propertyName) !== propertyNames.lastIndexOf(propertyName)) {
            return false; // Duplicate value
        }

        var attributeNames = [];
        getAttributeNames(attributes, attributeNames, "");
        if (!attributeNames.includes(propertyName)) {
            return false;
        }
        
        return true;
    }
    
    function validateArrayName(arrayName, arrayNames) {
        if (!arrayName || arrayName === "") {
            return false; // Empty value
        }
        
        if (arrayNames.indexOf(arrayName) !== arrayNames.lastIndexOf(arrayName)) {
            return false; // Duplicate value
        }
        
        return true;
    }
    
    function createInputElement(propertyInfo) {
        var newPropertyValueField;
        
        // Create a property value widget, based on the property name.
        // A list of all available value types can be found in the plot-schema.json file (at level "defs.valObjects").
        switch(propertyInfo.valType) {
            case "color":
                newPropertyValueField = $('<input/>', {type:"color"});
                break;
            case "string":
                newPropertyValueField = $('<input/>', {type:"text"});
                break;
            case "enumerated":
                newPropertyValueField = $('<select/>', {type:"text"});
                
                // The available values are listed in "values"
                if (propertyInfo.values) {
                    propertyInfo.values.forEach(function(value) {
                        newPropertyValueField.append($('<option>', {value: value, text: value}));
                    });
                }
                break;
            case "integer":
                // Apply step size 1 to allow allow integer values
                newPropertyValueField = $('<input/>', {type:"number", step:"1"});

                if (propertyInfo.min) {
                    newPropertyValueField.attr('min', propertyInfo.min);
                }

                if (propertyInfo.max) {
                    newPropertyValueField.attr('max', propertyInfo.max);
                }                        
                break;
            case "number":
                newPropertyValueField = $('<input/>', {type:"number"});
                // TODO which step size do we need to specify? Remark: The default stepping value for number inputs is 1, allowing only integers to be enteredâ€”unless the stepping base is not an integer.                                
                if (propertyInfo.min) {
                    newPropertyValueField.attr('min', propertyInfo.min);
                }

                if (propertyInfo.max) {
                    newPropertyValueField.attr('max', propertyInfo.max);
                }
                break;
            case "any":      
                break;
            case "info_array": // TODO "description": "An {array} of plot information.",
            case "colorlist":  // TODO "description": "A list of colors. Must be an {array} containing valid colors.",
            case "colorscale": // TODO an array with minimum 2 elements .  For example, `[[0, 'rgb(0,0,255)'], [1, 'rgb(255,0,0)']] 
            case "data_array":
                newPropertyValueField = $('<select/>', {type:"text"});
                var dataArrays = getArrayNames(propertyInfo.valType);
                dataArrays.forEach(function(arrayName) {
                    // Note that a prefix will be added to the value, to make sure we know later on (i.e. in the Node-RED dashbhoard) that
                    // this array name needs to be replaced by the corresponding array content ...
                    newPropertyValueField.append($('<option>', {value: PLOTLY_ARRAY_PREFIX + arrayName, text: arrayName}));
                });
                break;
            case "flaglist":
                // Create a multi-select dropdown, since multiple flags can be selected simultaneously
                newPropertyValueField = $('<select multiple></select>', {type:"text"});
                // TODO what means "Values in `extras` cannot be combined" ??                                
                if (propertyInfo.flags) {
                    propertyInfo.flags.forEach(function(flag) {
                        newPropertyValueField.append($('<option>', {value: flag, text: flag}));
                    });
                }

                // A property of type 'flaglist' will be visualised as a multiselect dropdown.  However such a dropdown will
                // require the selected value as an array (e.g. ['a', 'b', 'c']), while we have stored it for Plotly as a '+' separated string (e.g. "a+b+c").
                if (typeof property.value === 'string') {
                    property.value = property.value.split('+');
                }
                
                break;
            case "boolean":
                newPropertyValueField = $('<select/>', {type:"text"});
                // Only strings and numbers can be used as an option value in a select element.
                // Therefore we will use string values, and replace those by booleans afterwards on the server side.
                newPropertyValueField.append($('<option>', {value: PLOTLY_BOOLEAN_TRUE, text: "true"}));
                newPropertyValueField.append($('<option>', {value: PLOTLY_BOOLEAN_FALSE, text: "false"}));
                break;
            case "subplotid":
                // The property value will be a reference to a shared color axis (e.g. *coloraxis*, *coloraxis2*, *coloraxis3* ...).
                newPropertyValueField = $('<input/>', {type:"color", pattern:pattern});
                if (propertyInfo.regex) {
                    // The regex supplied in the plot-schema.json file will look like this: "/^coloraxis([2-9]|[1-9][0-9]+)?$/".
                    // The "/" at the start and the end of the regex should be removed.
                    // The ^ at the start and the $ at the end, are not required in a html5 input pattern (but they are allowed).
                    // See https://stackoverflow.com/questions/9142208/should-i-use-and-in-html5-input-regex-pattern-validation
                    var pattern = propertyInfo.regex.replace(/^\/|\/$/g, '');
                    newPropertyValueField.attr('pattern', pattern);
                }
                break;
            case "angle":
                // TODO should we use step=1 (integers) or something else?
                newPropertyValueField = $('<input/>', {type:"number", min:"-180", max:"180"});
                break;
            default:
                // Unsupported type, so return a disable edit field
                newPropertyValueField = $('<input/>', {type:"number", disabled:"disabled"});
        }
        
        newPropertyValueField.addClass("node-input-property-value");
        newPropertyValueField.css({"width":"45%","margin-left":"5px","margin-right":"5px"});

        // If the json scheme specifies a default value, then apply that value, except for a disabled field
        if (propertyInfo.dflt !== undefined && !newPropertyValueField.prop('disabled')) {
            newPropertyValueField.val(propertyInfo.dflt);
        }
        
        return newPropertyValueField;
    }
    
    // Store the config screen data into the specified object
    function storeConfigScreen(obj, node) {
        obj.layoutProperties = [];
        obj.traces = [];
        obj.arrays = [];
        
        // Copy all the layout properties from the editableList (in the first tabsheet) to the obj
        var layoutPropertiesList = $("#node-input-layout-container").editableList('items');
        layoutPropertiesList.each(function(i) {
            var row = $(this);  
            var layoutProperty = {
                name: row.find(".node-input-property-name").val(),
                value: row.find(".node-input-property-value").val() 
            }
            obj.layoutProperties.push(layoutProperty);
        });
                       
        // If trace properties are being displayed currently (in the third tabsheet), then copy those properties to the trace list (in the second tabsheet)
        if (node.selectedTraceRow) {
            var selectedTraceName = node.selectedTraceRow.find(".node-input-trace-name").val();
            copyTraceProperties(selectedTraceName);
        }

        // Copy all the traces from the editableList (in the second tabsheet) to the obj
        var tracesList = $("#node-input-traces-container").editableList('items');
        tracesList.each(function(i) {
            var row = $(this);  
            var trace = {
                name: row.find(".node-input-trace-name").val(),
                type: row.find(".node-input-trace-type").val(),
                // The row itself is generated by Node-RED (as a wrapper around our DIV row)
                properties: row.find(".node-input-trace-div").data('trace-properties') 
            }
            obj.traces.push(trace);
        });
        
        // If array items are being displayed currently (in the fifth tabsheet), then copy those items to the arrays list (in the fourth tabsheet)
        if (node.selectedArrayRow) {
            var selectedArrayName = node.selectedArrayRow.find(".node-input-array-name").val();
            copyArrayItems(selectedArrayName);
        }

        // Copy all the arrays from the editableList (in the fourth tabsheet) to the obj
        var arraysList = $("#node-input-arrays-container").editableList('items');
        arraysList.each(function(i) {
            var row = $(this);  
            var array = {
                name: row.find(".node-input-array-name").val(),
                type: row.find(".node-input-array-type").val(),
                // The row itself is generated by Node-RED (as a wrapper around our DIV row)
                items: row.find(".node-input-array-div").data('array-items') 
            }
            obj.arrays.push(array);
        });
    }
    
    // Based on http://www.coding4developers.com/javascript/how-to-pretty-json-fromat-using-javascriptjquery/
    function prettyPrintJson(obj) {
        var jsonLine = /^( *)("[\w]+": )?("[^"]*"|[\w.+-]*)?([,[{])?$/mg;
        return JSON.stringify(obj, null, 3)
            .replace(/&/g, '&amp;').replace(/\\"/g, '&quot;')
            .replace(/</g, '&lt;').replace(/>/g, '&gt;')
            .replace(jsonLine, function(match, pIndent, pKey, pVal, pEnd) {
                var key = '<span class=json-key>';
                var val = '<span class=json-value>';
                var str = '<span class=json-string>';
                var r = pIndent || '';
                if (pKey)
                    r = r + key + pKey.replace(/[": ]/g, '') + '</span>: ';
                if (pVal)
                    r = r + (pVal[0] == '"' ? str : val) + pVal + '</span>';
                return r + (pEnd || '');
            });
    }
    
    // Load the plot-schema.json from the server once (synchronous), and share it between all Plotly nodes.  This should
    // be done in advance, since the validation functions (called by Node-RED) will be executed before the oneditprepare...
    var plotlyJsonSchema = $.ajax({
        type: 'PUT',
        dataType: "json",
        url: "/ui_plotly_chart/flow/json_schema",
        async: false,
        data: {}
    }).responseJSON;
    
    // Load the Plotly library in the head of the page, not locally in the html!
    // See https://stackoverflow.com/questions/45868530/why-am-i-getting-an-uncaught-referenceerror-plotly-is-not-defined
    // var head = document.getElementsByTagName('head')[0];
    // var script = document.createElement('script');
    // script.type = 'text/javascript';
    // script.src = 'ui_plotly_chart/static/plotly_lib';
    // script.async = false;
    // head.appendChild(script);
            
    RED.nodes.registerType('ui_plotly-chart',{
        category: 'dashboard',
        color: 'rgb( 63, 173, 181)',
        defaults: {
            group: {type: 'ui_group', required:true},
            order: {value: 0},
            width: {
                value: 0,
                validate: function(v) {
                    var valid = true;
                    var width = v||0;
                    var currentGroup = $('#node-input-group').val()|| this.group;
                    var groupNode = RED.nodes.node(currentGroup);
                    valid = !groupNode || +width <= +groupNode.width;
                    $("#node-input-size").toggleClass("input-error",!valid);
                    return valid;
                }},
            height: {value: 0},
            name: {value: ''},
            inputField: {value: "payload", required: true, validate: RED.validators.typedInput("inputFieldType")},
            inputFieldType: {value: "msg"},
            sharedState: {value: "shared_state", required: true, validate: RED.validators.typedInput("sharedStateType")},
            sharedStateType: {value: "node"},
            validateInputMsg: {value: true},
            layoutProperties: {value: null, validate:function(_layoutProperties) {
                if (_layoutProperties) {
                    // Create an array of layout property names
                    var layoutPropertyNames = [];
                    _layoutProperties.forEach(function (layoutProperty) {
                        layoutPropertyNames.push(layoutProperty.name);
                    });
                    
                    // Execute the SAME validations as in the (layout properties) editableList.
                    // Don't use forEach because then the return value isn't passed to Node-RED!
                    for (var i = 0; i < layoutPropertyNames.length; i++) {
                        var layoutPropertyName = layoutPropertyNames[i];
                        
                        if (!validatePropertyName(layoutPropertyName, layoutPropertyNames, plotlyJsonSchema.layout.layoutAttributes)) {
                            return false;
                        }
                    }
                }
                
                return true;
            }},
            traces: {value: [], validate:function(_traces) {
                // Create an array of trace names
                var traceNames = [];
                _traces.forEach(function (trace) {
                    traceNames.push(trace.name);
                });
                
                // Execute the SAME validations as in the (traces) editableList, but now for each trace.
                // Don't use forEach because then the return value isn't passed to Node-RED!
                for (var i = 0; i < traceNames.length; i++) {
                    var traceName = traceNames[i];

                    if (!validateTraceName(traceName, traceNames)) {
                        return false;
                    }
                }
                
                // Validate the properties of all traces.
                // Don't use forEach because then the return value isn't passed to Node-RED!
                for (var j = 0; j < _traces.length; j++) {
                    var trace = _traces[j];
                    
                    // Create an array of trace property names
                    var tracePropertyNames = [];
                    trace.properties.forEach(function (traceProperty) {
                        tracePropertyNames.push(traceProperty.name);
                    });
                    
                    // Execute the SAME validations as in the (traces) editableList, but now for each trace.
                    // Don't use forEach because then the return value isn't passed to Node-RED!
                    for (var k = 0; k < tracePropertyNames.length; k++) {
                        var tracePropertyName = tracePropertyNames[k];
                        
                        if (!validatePropertyName(tracePropertyName, tracePropertyNames, plotlyJsonSchema.traces[trace.type].attributes)) {
                            return false;
                        }
                    }
                }
                
                return true;
            }},
            arrays: {value: [], validate:function(_arrays) {
                // Create an array of array names
                var arrayNames = [];
                _arrays.forEach(function (array) {
                    arrayNames.push(array.name);
                });
                
                // Execute the SAME validations as in the (arrays) editableList, but now for each array.
                // Don't use forEach because then the return value isn't passed to Node-RED!
                for (var i = 0; i < arrayNames.length; i++) {
                    var arrayName = arrayNames[i];
                    
                    if (!validateArrayName(arrayName, arrayNames)) {
                        return false;
                    }
                }
                
                return true;
            }}
        },
        inputs:1,
        outputs:1,
        icon: "font-awesome/fa-area-chart", 
        paletteLabel:"Plotly Chart",
        label: function() {
            return this.name||"Plotly Chart";
        },
        labelStyle: function() {
            return this.name?"node_label_italic":"";
        },
        oneditprepare: function() {
            var node = this;

            // Show a popup when the size element is being clicked
            $("#node-input-size").elementSizer({
                width: "#node-input-width",
                height: "#node-input-height",
                group: "#node-input-group"
            });
            
            $('#node-input-inputField').typedInput({
                typeField: $("#node-input-inputFieldType"),
                types: ['msg']
            });
            
            // Show a custom "None" option in the sharedState field
            var noneSharedStateType = {
                value: "none",
                label: "None",
                hasValue: false // No input field at the right side
            };
            
            // Show a custom "Volatile" option in the sharedState field
            var volatileSharedStateType = {
                value: "volatile",
                label: "Volatile",
                hasValue: false // No input field at the right side
            };
            
            // Show a custom "node." option in the sharedState field.
            // Don't offer 'flow' or 'global' to avoid clashes between multiple nodes accessing the same memory
            var nodeContextSharedStateType = {
                value: "node",
                label: "node.",
                hasValue: true // Input field at the right side
            };
            
            $('#node-input-sharedState').typedInput({
                typeField: $("#node-input-sharedStateType"),
                types: [noneSharedStateType, volatileSharedStateType, nodeContextSharedStateType, 'msg']
            });

            $("#node-input-validate").click(function () {
                // Convert the data from the config screen to an object.  This way we have the same data that will normally
                // be send to the server, when the flow would be deployed...
                var nodeConfig = {};
                storeConfigScreen(nodeConfig, node);

                // Let the server http endpoint convert our node config to a Plotly config, so we can simulate
                // what will be send afterwards to Plotly...
                $.ajax({
                    type: 'PUT',
                    contentType: 'application/json',
                    url: "/ui_plotly_chart/flow/validate_config",
                    data: JSON.stringify({node_config: nodeConfig}),
                    success: function(jsonResult){
                        var dialogHtml;
                                                  
                        if (jsonResult.length > 0) {
                            dialogHtml = "<div><ul>";
                            jsonResult.forEach( function(problem) {
                                dialogHtml += "<li><i>" + problem.container + ":</i> " + problem.msg + "</li>";
                            });
                            dialogHtml += "</ul></div>";
                        } else {
                            dialogHtml = "Validation successful";
                        }
                        
                        // Show the Plotly config in a modal popup dialog
                        $('<div></div>').appendTo('body')
                            .html(dialogHtml)
                            .dialog({
                                modal: true,
                                title: 'Plotly config validation',
                                zIndex: 10000,
                                autoOpen: true,
                                height: '300',
                                width: '700',
                                resizable: true,
                                buttons: [{
                                    text: "Close",
                                    click: function () {
                                        $(this).dialog("close");
                                    },
                                }],
                                close: function(event, ui) {
                                    // Do nothing ...
                                    $(this).remove();
                                }
                        });
                    },
                    error: function(){
                        alert("Problem while validating.  See Node-RED log for more information");
                    }
                });
            });

            // 
            $("#node-input-plotlyConfig").click(function () {
                function syntaxHighlight(json) {
                    json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                        var cls = 'number';
                        if (/^"/.test(match)) {
                            if (/:$/.test(match)) {
                                cls = 'key';
                            } else {
                                cls = 'string';
                            }
                        } else if (/true|false/.test(match)) {
                            cls = 'boolean';
                        } else if (/null/.test(match)) {
                            cls = 'null';
                        }
                        return '<span class="' + cls + '">' + match + '</span>';
                    });
                }

                // Convert the data from the config screen to an object.  This way we have the same data that will normally
                // be send to the server, when the flow would be deployed...
                var nodeConfig = {};
                storeConfigScreen(nodeConfig, node);
                
                // Let the server http endpoint convert our node config to a Plotly config, so we can simulate
                // what will be send afterwards to Plotly...
                $.ajax({
                    type: 'PUT',
                    contentType: 'application/json',
                    url: "/ui_plotly_chart/flow/convert_to_plotly_format",
                    data: JSON.stringify({node_config: nodeConfig}),
                    success: function(jsonResult){
                        var plotlyConfig = JSON.stringify(jsonResult, null, 2); // spacing level = 2
                        plotlyConfig = syntaxHighlight(plotlyConfig);
                        
                        // Use a "pre" element (instead of div) to show the indentations.
                        // See https://stackoverflow.com/questions/4810841/pretty-print-json-using-javascript (http://jsfiddle.net/KJQ9K/554/)
                        var dialogHtml = "<style>" +
                                         "   pre { padding: 5px; margin: 5px; } " +
                                         "   .string { color: green; } " +
                                         "   .number { color: darkorange; } " +
                                         "   .boolean { color: blue; } " +
                                         "   .null { color: magenta; } " +
                                         "   .key { color: red; } " +
                                         "</style> " +
                                         "<pre> " +
                                         plotlyConfig +
                                         " </pre>";
                        
                        // Show the Plotly config in a modal popup dialog
                        $('<div></div>').appendTo('body')
                            .html(dialogHtml)
                            .dialog({
                                modal: true,
                                title: 'Plotly JSON config',
                                zIndex: 10000,
                                autoOpen: true,
                                height: '400',
                                width: '350',
                                resizable: true,
                                buttons: [{
                                    text: "Close",
                                    click: function () {
                                        $(this).dialog("close");
                                    },
                                }],
                                close: function(event, ui) {
                                    // Do nothing ...
                                    $(this).remove();
                                }
                        });
                    },
                    error: function(){
                        alert("Problem while getting the config.  See Node-RED log for more information");
                    }
                });
            });
            
            // Make sure that the selected rows (from a previous time this config screen has been opened) are forgotten.
            // Otherwise this node will think that the selected trace/array has no properties/items (since the editableList is empty).
            // Which means that the loaded properties/items would be removed from this node, which is incorrect...
            node.selectedTraceRow = null;
            node.selectedArrayRow = null;

            // When another trace is being selected in the dropdown, its trace properties should be displayed in the editableList (in the third tabsheet)
            $("#node-input-trace").on("change", function(){
                // If the properties of another trace are currently being displayed (in the third tabsheet), then store those
                // trace properties in the traces list (in the second tabsheet).
                if (node.selectedTraceRow) {
                    var previousTraceName = node.selectedTraceRow.find(".node-input-trace-name").val();
                    copyTraceProperties(previousTraceName);
                    
                    // Remove the trace property rows from the trace properties editableList (in the third tabsheet)
                    $("#node-input-properties-container").editableList('empty');
                }

                // The this.value contains the name of the currently selected trace
                node.selectedTraceRow = getTraceRow(this.value);
                
                if (node.selectedTraceRow) {
                    // Show the properties of the currently selected trace row in the editableList
                    node.selectedTraceRow.data('trace-properties').forEach(function(traceProperty) {
                        $("#node-input-properties-container").editableList('addItem', traceProperty);
                    });
                }
            });
            
            // When another array is being selected in the dropdown, its array items should be displayed in the editableList (in the fifth tabsheet)
            $("#node-input-array").on("change", function(){
                // If the items of another array are currently being displayed (in the fifth tabsheet), then store those
                // array items in the array list (in the fourth tabsheet).
                if (node.selectedArrayRow) {
                    var previousArrayName = node.selectedArrayRow.find(".node-input-array-name").val();
                    copyArrayItems(previousArrayName);
                    
                    // Remove the array rows from the array items editableList (in the fifth tabsheet)
                    $("#node-input-items-container").editableList('empty');
                }

                // The this.value contains the name of the currently selected list
                node.selectedArrayRow = getArrayRow(this.value);
                
                if (node.selectedArrayRow) {
                    // Show the items of the currently selected array row in the editableList
                    node.selectedArrayRow.data('array-items').forEach(function(arrayItem) {
                        $("#node-input-items-container").editableList('addItem', arrayItem);
                    });
                }
            });
            
            node.previousTabId = null;

            // Show tabsheets
            node.tabs = RED.tabs.create({
                id: "node-plotly-tabs",
                onchange: function(tab) {
                    //console.log("tabs.onchange",tab);
                    // Show only the content (i.e. the children) of the selected tabsheet, and hide the others
                    $("#node-plotly-tabs-content").children().hide();
                    $("#" + tab.id).show();
                    
                    var traceDropdown = $("#node-input-trace");
                    var arrayDropdown = $("#node-input-array");
                    
                    if (tab.id === "node-plotly-tab-traceproperties") {
                        traceDropdown.empty();
                        
                        // When going to the third tabsheet, fill the traces dropdown (on the third tabsheet) with traces information (from the second tabsheet)
                        var tracesList = $("#node-input-traces-container").editableList('items');
                        tracesList.each(function(i) {
                            var row = $(this);  
                            var traceName = row.find(".node-input-trace-name").val();
                            var traceType = row.find(".node-input-trace-type").val();
                            traceDropdown.append($('<option>', {value: traceName, text: traceName + " (" + traceType + ")"}));
                        });
                        
                        // Select the first option in the dropdown, and trigger its change event (which will show all the 
                        // corresponding trace properties in the editableList on the third tabsheet)
                        traceDropdown.val($("#node-input-trace option:first").val());
                        traceDropdown.change();
                    }
                    else if (node.previousTabId === "node-plotly-tab-traceproperties") {
                        // When leaving the third tabsheet: If trace properties are being displayed currently (in the third tabsheet),  
                        // then copy those properties to the trace list (in the second tabsheet).  And clear the trace dropdown and the properties editableList
                        // (both on the third tabsheet), otherwise the data will be used afterwards which causes unwanted behaviour.
                        // Do all of this by clearing the trace dropdown and trigger its 'change' event, to reuse the existing code ...
                        traceDropdown.empty();
                        traceDropdown.change();
                    }
                    else if (tab.id === "node-plotly-tab-arrayitems") {
                        arrayDropdown.empty();
                        
                        // When going to the fifth tabsheet, fill the array dropdown (on the fifth tabsheet) with array information (from the fourth tabsheet)
                        var arraysList = $("#node-input-arrays-container").editableList('items');
                        arraysList.each(function(i) {
                            var row = $(this);  
                            var arrayName = row.find(".node-input-array-name").val();
                            var arrayType = row.find(".node-input-array-type").val();
                            arrayDropdown.append($('<option>', {value: arrayName, text: arrayName + " (" + arrayType + ")"}));
                        });
                        
                        // Select the first option in the dropdown, and trigger its change event (which will show all the 
                        // corresponding array items in the editableList on the fifth tabsheet)
                        arrayDropdown.val($("#node-input-array option:first").val());
                        arrayDropdown.change();
                    }
                    else if (node.previousTabId === "node-plotly-tab-arrayitems") {
                        // When leaving the fifth tabsheet: If array items are being displayed currently (in the fifth tabsheet),  
                        // then copy those items to the arrays list (in the fourth tabsheet).  And clear the array dropdown and the items editableList
                        // (both on the fifth tabsheet), otherwise the data will be used afterwards which causes unwanted behaviour.
                        // Do all of this by clearing the array dropdown and trigger its 'change' event, to reuse the existing code ...
                        arrayDropdown.empty();
                        arrayDropdown.change();
                    }
                                        
                    node.previousTabId = tab.id;
                }
            });
            node.tabs.addTab({
                id: "node-plotly-tab-layout",
                label: "Layout"
            });
            node.tabs.addTab({
                id: "node-plotly-tab-traces",
                label: "Traces"
            });
            node.tabs.addTab({
                id: "node-plotly-tab-traceproperties",
                label: "Properties"
            })
            node.tabs.addTab({
                id: "node-plotly-tab-arrays",
                label: "Arrays"
            });
            node.tabs.addTab({
                id: "node-plotly-tab-arrayitems",
                label: "Items"
            })

            // Show an editableList with layout properties on the first tabsheet
            var layoutPropertiesEditableList = $("#node-input-layout-container").css('min-height','250px').css('min-width','450px').editableList({
                header: $("<div>").append($.parseHTML(
                   "<div style='width:5%; margin-left:5px; display: inline-grid'></div>" +
                   "<div style='width:45%; margin-left:5px; display: inline-grid'><b>Property name</b></div>" +
                   "<div style='width:40%; margin-left:5px; display: inline-grid'><b>Property value</b></div>" +
                   "<div style='width:5%; margin-left:5px; display: inline-grid'></div>")),
                addItem: function(container,i,layoutProperty) {
                    container.css({
                        overflow: 'hidden',
                        whiteSpace: 'nowrap'
                    });

                    // Add a new row to the html table
                    var row = $('<div/>').appendTo(container);
                    
                    // Column 1 : Add a text field to the new row, that represents the layout property name (type string)
                    var layoutPropertyNameField = $('<input/>', {class:"node-input-property-name", type:"text"}).css({"width":"50%","margin-left":"5px","margin-right":"5px"}).appendTo(row);
                    layoutPropertyNameField.autocomplete({
                        //minChars: 0, // Show all autocomplete options when focus on the field
                        classes: {
                            "ui-autocomplete": "ui-svg-ui-autocomplete", //add custom class for styling the dropdown
                        },
                        source: function(req, add){
                            // Get all the layout attributes information from the plot-schema.json file
                            var layoutAttributes = plotlyJsonSchema.layout.layoutAttributes;
                            
                            // Get all the layout attribute names, and the nested attribute names (separated by dots)
                            var layoutAttributeNames = [];
                            getAttributeNames(layoutAttributes, layoutAttributeNames, "");

                            if (req.term === "*") {
                                // Show all layout attribute names
                                add(layoutAttributeNames);
                            }
                            else {
                                // Before adding the found layout attribute names, filter them (matching the entered term anywhere in the attribute name)
                                add($.ui.autocomplete.filter(layoutAttributeNames, req.term));
                            }
                        }
                    }).keyup(function (e) {
                        // Automatically hide the autocomplete list when 'enter' has been pressed.
                        // See https://stackoverflow.com/a/9602479
                        if (!e) e = window.event;   
                        if (e.keyCode == '13'){
                            layoutPropertyNameField.autocomplete('close');
                            return false;
                        }
                    })/*.focus(function() {
                        // TODO why doesn't jquery doesn't show all options on focus (in combination with minChars:0)???
                        layoutPropertyNameField.autocomplete("search", $(this).val());
                    });*/
                    layoutPropertyNameField.on("change paste", function() {
                        var propertyName = this.value;
                        
                        var propertyInfo = getAttribute(plotlyJsonSchema.layout.layoutAttributes, propertyName);
                        
                        // When no propertyInfo available, it seems that the entered layout property name is incorrect
                        if (!propertyInfo) {
                            // Make sure we go to the 'default' case below (to create a disabled text box)
                            propertyInfo = {
                                valType: "xxxxxx"
                            }
                        }
                        
                        // Remove the previous property value widget
                        var previousPropertyValueField = this.parentElement.querySelector(".node-input-property-value");
                        if (previousPropertyValueField) {
                            previousPropertyValueField.remove();
                        }
                        
                        // Show the layout property description as tooltip
                        if (propertyInfo.description) {
                            layoutPropertyNameField.attr('title', propertyInfo.description);
                        }
                        
                        // Create a new input element, based on the layout property information
                        var newPropertyValueField = createInputElement(propertyInfo);
                        newPropertyValueField.appendTo(row);
                        
                        // Validate the layout property name in this field
                        var propertyNameFields = layoutPropertiesEditableList.find(".node-input-property-name");
                        var propertyNames = getFieldValues(propertyNameFields);
                        var valid = validatePropertyName(propertyName, propertyNames, plotlyJsonSchema.layout.layoutAttributes);
                        
                         // Show a red border around the array name field, when a problem has been found
                        if (valid) {
                            $(this).css('border', '');
                        }
                        else {
                            $(this).css('border', '1px solid rgb(214, 97, 95)');
                        }
                    });
                    
                    // By setting the layout property name, the above change handler will create the corresponding layout property value field (as second column).
                    layoutPropertyNameField.val(layoutProperty.name);
                    layoutPropertyNameField.change(); // Validate the field also after loading (when opening the config screen)
                    layoutPropertyNameField.focus();
 
                    // Apply the layout property value only when the field is not disabled
                    var layoutPropertyValueField = row.find(".node-input-property-value");
                    if (!layoutPropertyValueField.prop('disabled')) {
                        layoutPropertyValueField.val(layoutProperty.value);
                    }
                },
                removable: true,
                sortable: true,
                addButton: "add layout property"
            });
            
            // Show all the layout properties from the node in the editableList
            if (node.layoutProperties) {
                node.layoutProperties.forEach( function (layoutProperty) {
                    layoutPropertiesEditableList.editableList('addItem', layoutProperty);
                });
            }
            else {
                // When the layoutProperties array doesn't exist yet (i.e. value 'null'), then add some default layout properties automatically
                layoutPropertiesEditableList.editableList('addItem', {name: "title.text"});
                layoutPropertiesEditableList.editableList('addItem', {name: "xaxis.title.text"});
                layoutPropertiesEditableList.editableList('addItem', {name: "xaxis.type"});
                layoutPropertiesEditableList.editableList('addItem', {name: "yaxis.title.text"});
                layoutPropertiesEditableList.editableList('addItem', {name: "title.font.size", value: 22});
                layoutPropertiesEditableList.editableList('addItem', {name: "autosize", value: true});
            }

            // Show an editableList with traces on the second tabsheet
            var tracesEditableList = $("#node-input-traces-container").css('height','200px').css('min-height','200px').css('min-width','450px').editableList({
                header: $("<div>").append($.parseHTML(
                   "<div style='width:5%; margin-left:5px; display: inline-grid'></div>" +
                   "<div style='width:45%; margin-left:5px; display: inline-grid'><b>Trace name</b></div>" +
                   "<div style='width:40%; margin-left:5px; display: inline-grid'><b>Trace type</b></div>" +
                   "<div style='width:5%; margin-left:5px; display: inline-grid'></div>")),
                addItem: function(container,i,trace) {
                    var newTrace = false;
                    
                    // When trace === {} then we have a new list item (i.e. user pressed the addItem button), so set the default values
                    if (Object.keys(trace).length === 0) {
                        trace.name = "";
                        trace.type = "scatter";
                        trace.properties = [];
                        newTrace = true;
                    }
                    
                    container.css({
                        overflow: 'hidden',
                        whiteSpace: 'nowrap'
                    });
                    
                    // Add a new row to the html table
                    var row = $('<div/>', {class:"node-input-trace-div"}).appendTo(container);
                    
                    // Store the trace properties also on the DIV row element (as JQuery data!).  This way we can make sure the link 
                    // between the trace and its properties is always fixed, even when the trace name is changed afterwards.  Indeed the trace
                    // name / trace type / trace properties are all stored under a single DIV element.
                    row.data('trace-properties', trace.properties); 
                    
                    // Column 1 : Add a text field to the new row, that represents the trace name (type string)
                    var traceNameField = $('<input/>', {class:"node-input-trace-name", type:"text"}).css({"resize":"none","vertical-align":"top","width":"40%","margin-left":"5px","margin-right":"5px"}).appendTo(row);
                    traceNameField.on("change paste", function() {
                        var traceName = this.value;

                        // Validate the trace name in this field
                        var traceNameFields = tracesEditableList.find(".node-input-trace-name");
                        var traceNames = getFieldValues(traceNameFields);
                        var valid = validateTraceName(traceName, traceNames);
                        
                        // Show a red border around the trace name field, when a problem has been found
                        if (valid) {
                            $(this).css('border', '');
                        }
                        else {
                            $(this).css('border', '1px solid rgb(214, 97, 95)');
                        }
                    });
                    traceNameField.val(trace.name);
                    traceNameField.change(); // Validate the field also after loading (when opening the config screen)
                    traceNameField.focus();
                    
                    // Column 2 : Add a select field to the new row, that represents the trace type (type string).
                    // Note that the "size" is required otherwise no tooltips will be showed on the select element
                    var traceTypeField = $('<select/>', {class:"node-input-trace-type", type:"text", size:"7"}).css({"width":"33%","margin-right":"10px"}).appendTo(row);

                    // Load all available trace types from the plot-schema.json file
                    Object.keys(plotlyJsonSchema.traces).forEach(function(key) {
                        var trace = plotlyJsonSchema.traces[key];

                        // For trace types with composite names (i.e. more than 1 word), there seems to be an hrName available...
                        var traceName = trace.meta.hrName || key;
                        
                        // The hrname is e.g. 'scatter_3d' which needs to become 'Scatter 3D'
                        traceName = traceName.replace(/_/g, ' ');
                        traceName = traceName.charAt(0).toUpperCase() + traceName.slice(1);

                        var option = traceTypeField.append($('<option>', {value: key, text: traceName, title: trace.meta.description}));
                    });

                    traceTypeField.on("change paste", function() {
                        // Remove all the existing trace properties (which belonged to the previous trace type)
                        row.data('trace-properties', []);
                        
                        // Copy the tooltip from the selected option to the select field
                        var optionTitle = $(this).children("option:selected").attr('title');
                        traceTypeField.attr("title", optionTitle);
                    });
                    traceTypeField.val(trace.type);
                    
                    // Make sure the "Properties" tabsheet gets the correct status (based on the number of traces available).
                    // Only call this when a new trace is being added (via the 'Add trace' button), but not during loading of 
                    // existing traces in the oneditprepare.  Because at that point not all editableLists (used in the setupTabsheets
                    // function) exist already, resulting in "cannot call methods on editableList prior to initialization".
                    // At the end of oneditprepare, the setupTabsheets function will be called when all lists are initialized...
                    if (newTrace) {
                        setupTabsheets(node);
                    }
                },
                removeItem: function(data) {
                    // Make sure the "Properties" tabsheet gets the correct status (based on the number of traces available)
                    setupTabsheets(node);
                },
                removable: true,
                sortable: true,
                addButton: "add trace"
            });
            
            // Show all the traces from the node in the editableList
            if (node.traces) {
                node.traces.forEach( function (trace) {
                    tracesEditableList.editableList('addItem', trace);
                })
            }

            // Show an editableList with trace properties on the third tabsheet
            var tracePropertiesEditableList = $("#node-input-properties-container").css('min-height','250px').css('min-width','450px').editableList({
                header: $("<div>").append($.parseHTML(
                   "<div style='width:5%; margin-left:5px; display: inline-grid'></div>" +
                   "<div style='width:45%; margin-left:5px; display: inline-grid'><b>Property name</b></div>" +
                   "<div style='width:40%; margin-left:5px; display: inline-grid'><b>Property value</b></div>" +
                   "<div style='width:5%; margin-left:5px; display: inline-grid'></div>")),
                addItem: function(container,i, traceProperty) {
                    container.css({
                        overflow: 'hidden',
                        whiteSpace: 'nowrap'
                    });

                    // Add a new row to the html table
                    var row = $('<div/>').appendTo(container);
                    
                    // Column 1 : Add a text field to the new row, that represents the trace property name (type string)
                    var tracePropertyNameField = $('<input/>', {class:"node-input-property-name", type:"text"}).css({"width":"50%","margin-left":"5px","margin-right":"5px"}).appendTo(row);
                    tracePropertyNameField.autocomplete({
                        //minChars: 0, // Show all autocomplete options when focus on the field
                        classes: {
                            "ui-autocomplete": "ui-svg-ui-autocomplete", //add custom class for styling the dropdown
                        },
                        source: function(req, add){
                            // Get the trace type (e.g. "scatter") of the selected trace row
                            var selectedTraceType = node.selectedTraceRow.find(".node-input-trace-type").val();
                            
                            // Get all the attribute information from the plot-schema.json file
                            var traceAttributes = plotlyJsonSchema.traces[selectedTraceType].attributes;
                            
                            // Get all the attribute names, and the nested attribute names (separated by dots)
                            var attributeNames = [];
                            getAttributeNames(traceAttributes, attributeNames, "");

                            if (req.term === "*") {
                                // Show all attribute names
                                add(attributeNames);
                            }
                            else {
                                // Before adding the found attribute names, filter them (matching the entered term anywhere in the attribute name)
                                add($.ui.autocomplete.filter(attributeNames, req.term));
                            }
                        }
                    }).keyup(function (e) {
                        // Automatically hide the autocomplete list when 'enter' has been pressed.
                        // See https://stackoverflow.com/a/9602479
                        if (!e) e = window.event;   
                        if (e.keyCode == '13'){
                            tracePropertyNameField.autocomplete('close');
                            return false;
                        }
                    })/*.focus(function() {
                        // TODO why doesn't jquery doesn't show all options on focus (in combination with minChars:0)???
                        tracePropertyNameField.autocomplete("search", $(this).val());
                    });*/
                    tracePropertyNameField.on("change paste", function() {
                        var propertyName = this.value;
                        
                        var selectedTraceType = node.selectedTraceRow.find(".node-input-trace-type").val();

                        var propertyInfo = getAttribute(plotlyJsonSchema.traces[selectedTraceType].attributes, propertyName);
                        
                        // When no propertyInfo available, it seems that the entered trace property name is incorrect
                        if (!propertyInfo) {
                            // Make sure we go to the 'default' case below (to create a disabled text box)
                            propertyInfo = {
                                valType: "xxxxxx"
                            }
                        }
                        
                        // Remove the previous trace property value widget
                        var previousPropertyValueField = this.parentElement.querySelector(".node-input-property-value");
                        if (previousPropertyValueField) {
                            previousPropertyValueField.remove();
                        }
                        
                        // Show the trace property description as tooltip
                        if (propertyInfo.description) {
                            tracePropertyNameField.attr('title', propertyInfo.description);
                        }
                        
                        // Create a new input element, based on the trace property information
                        var newPropertyValueField = createInputElement(propertyInfo);
                        newPropertyValueField.appendTo(row);
                        
                        // Validate the trace property name in this field
                        var propertyNameFields = tracePropertiesEditableList.find(".node-input-property-name");
                        var propertyNames = getFieldValues(propertyNameFields);
                        var valid = validatePropertyName(propertyName, propertyNames, plotlyJsonSchema.traces[selectedTraceType].attributes);
                        
                         // Show a red border around the array name field, when a problem has been found
                        if (valid) {
                            $(this).css('border', '');
                        }
                        else {
                            $(this).css('border', '1px solid rgb(214, 97, 95)');
                        }
                    });
                    
                    // By setting the trace property name, the above change handler will create the corresponding trace property value field (as second column).
                    tracePropertyNameField.val(traceProperty.name);
                    tracePropertyNameField.change(); // Validate the field also after loading (when opening the config screen)
                    tracePropertyNameField.focus();
 
                    // Apply the trace property value only when the field is not disabled
                    var tracePropertyValueField = row.find(".node-input-property-value");
                    if (!tracePropertyValueField.prop('disabled')) {
                        tracePropertyValueField.val(traceProperty.value);
                    }
                },
                removable: true,
                sortable: true,
                addButton: "add trace property"
            });

            // Show an editableList with arrays on the fourth tabsheet
            var arraysEditableList = $("#node-input-arrays-container").css('height','200px').css('min-height','200px').css('min-width','450px').editableList({
                header: $("<div>").append($.parseHTML(
                   "<div style='width:5%; margin-left:5px; display: inline-grid'></div>" +
                   "<div style='width:45%; margin-left:5px; display: inline-grid'><b>Array name</b></div>" +
                   "<div style='width:40%; margin-left:5px; display: inline-grid'><b>Array type</b></div>" +
                   "<div style='width:5%; margin-left:5px; display: inline-grid'></div>")),
                addItem: function(container,i,array) {
                    var newArray = false;
                    
                    // When array === {} then we have a new array item (i.e. user pressed the addItem button), so set the default values
                    if (Object.keys(array).length === 0) {
                        array.name = "";
                        array.type = "colorlist";
                        array.items = [];
                        newArray = true;
                    }
                    
                    container.css({
                        overflow: 'hidden',
                        whiteSpace: 'nowrap'
                    });
                    
                    // Add a new row to the html table
                    var row = $('<div/>', {class:"node-input-array-div"}).appendTo(container);
                    
                    // Store the array items also on the DIV row element (as JQuery data!).  This way we can make sure the link 
                    // between the array and its items is always fixed, even when the array name is changed afterwards.  Indeed the array
                    // name / array type / array items are all stored under a single DIV element.
                    row.data('array-items', array.items); 
                    
                    // Column 1 : Add a text field to the new row, that represents the array name (type string)
                    var arrayNameField = $('<input/>', {class:"node-input-array-name", type:"text"}).css({"resize":"none","vertical-align":"top","width":"40%","margin-left":"5px","margin-right":"5px"}).appendTo(row);
                    arrayNameField.on("change paste", function() {
                        var arrayName = this.value;
                        
                        // Validate the array name in this field
                        var arrayNameFields = arraysEditableList.find(".node-input-array-name");
                        var arrayNames = getFieldValues(arrayNameFields);
                        var valid = validateArrayName(arrayName, arrayNames);
                        
                        // Show a red border around the array name field, when a problem has been found
                        if (valid) {
                            $(this).css('border', '');
                        }
                        else {
                            $(this).css('border', '1px solid rgb(214, 97, 95)');
                        }
                    });
                    arrayNameField.val(array.name);
                    arrayNameField.change(); // Validate the field also after loading (when opening the config screen)
                    arrayNameField.focus();
                    
                    // Column 2 : Add a select field to the new row, that represents the array type (type string).
                    var arrayTypeField = $('<select/>', {class:"node-input-array-type", type:"text"}).css({"width":"45%","margin-right":"10px"}).appendTo(row);
                    arrayTypeField.append($('<option>', {value: "data_array", text: "Data array" , title: plotlyJsonSchema.defs.valObjects.data_array.description}));
                    arrayTypeField.append($('<option>', {value: "info_array", text: "Info array" , title: plotlyJsonSchema.defs.valObjects.info_array.description}));
                    arrayTypeField.append($('<option>', {value: "colorlist" , text: "Color list" , title: plotlyJsonSchema.defs.valObjects.colorlist.description}));
                    arrayTypeField.append($('<option>', {value: "colorscale", text: "Color scale", title: plotlyJsonSchema.defs.valObjects.colorscale.description}));

                    arrayTypeField.on("change paste", function() {
                        // Remove all the existing array items (which belonged to the previous array type)
                        row.data('array-items', []);
                        
                        // Copy the tooltip from the selected option to the select field
                        var optionTitle = $(this).children("option:selected").attr('title');
                        arrayTypeField.attr("title", optionTitle);
                    });
                    arrayTypeField.val(array.type);
                    
                    // Make sure the "Items" tabsheet gets the correct status (based on the number of arrays available).
                    // Only call this when a new trace is being added (via the 'Add trace' button), but not during loading of 
                    // existing traces in the oneditprepare.  Because at that point not all editableLists (used in the setupTabsheets
                    // function) exist already, resulting in "cannot call methods on editableList prior to initialization".
                    // At the end of oneditprepare, the setupTabsheets function will be called when all lists are initialized...
                    if (newArray) {
                        setupTabsheets(node);
                    }
                },
                removeItem: function(data) {
                    // Make sure the "Properties" tabsheet gets the correct status (based on the number of traces available)
                    setupTabsheets(node);
                },
                removable: true,
                sortable: true,
                addButton: "add array"
            });
            
            // Show all the lists from the node in the editableList
            if (node.arrays) {
                node.arrays.forEach(function (array) {
                    arraysEditableList.editableList('addItem', array);
                });
            }
            
            // Show an editableList with array items on the fifth tabsheet
            var itemsEditableList = $("#node-input-items-container").css('min-height','250px').css('min-width','450px').editableList({
                addItem: function(container,i,item) {
                    container.css({
                        overflow: 'hidden',
                        whiteSpace: 'nowrap'
                    });

                    // Add a new row to the html table
                    var row = $('<div/>').appendTo(container);
                    
                    var selectedArrayType = node.selectedArrayRow.find(".node-input-array-type").val();
                    
                    // The input widget type depends on the selected array type
                    switch(selectedArrayType) {
                        case "data_array":
                            itemField = $('<input/>', {type:"text"});
                            break;
                        case "info_array":
                            // An {array} of plot information.
                            itemField = $('<input/>', {type:"text"});
                            break;
                        case "colorlist":
                            // An array of colors. Must be an {array} containing valid colors
                            itemField = $('<input/>', {type:"color"});
                            break;
                        case "colorscale":
                            // an array with minimum 2 elements .  For example, `[[0, 'rgb(0,0,255)'], [1, 'rgb(255,0,0)']]  
                            itemField = $('<input/>', {type:"color"});
                            break;
                    }

                    itemField.addClass("node-input-item-value");
                    itemField.css({"width":"80%","margin-left":"5px","margin-right":"5px"});
                    itemField.appendTo(row);
                    itemField.val(item.value);
                    itemField.focus();
                },
                removable: true,
                sortable: true,
                addButton: "add item"
            });
            
            // Make sure the tabsheets have the correct initial status (enabled or disabled), based on the data in the
            // editableLists which all will be initialized at this point.
            setupTabsheets(node);
        },
        oneditsave: function() {
            var node = this;
            
            // Store the config screen information into this node
            storeConfigScreen(node, node);
        },
    });
</script>

<script type="text/html" data-template-name="ui_plotly-chart">
    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    
    <div class="form-row" id="template-row-group">
        <label for="node-input-group"><i class="fa fa-table"></i> Group</span></label>
        <input type="text" id="node-input-group">
    </div>
    
    <div class="form-row" id="template-row-size">
        <label><i class="fa fa-object-group"></i> Size</span></label>
        <input type="hidden" id="node-input-width">
        <input type="hidden" id="node-input-height">
        <button class="editor-button" id="node-input-size"></button>
    </div>
    
    </br>
    
    <div class="form-row">
        <label style="padding-top: 8px" for="node-input-inputField"><i class="fa fa-sign-in"></i> Input field</label>
        <input type="text" id="node-input-inputField" style="width:70%">
        <input type="hidden" id="node-input-inputFieldType">
    </div>
    
    <div class="form-row">
        <label style="padding-top: 8px" for="node-input-sharedState"><i class="fa fa-sign-in"></i> Shared state</label>
        <input type="text" id="node-input-sharedState" style="width:70%">
        <input type="hidden" id="node-input-sharedStateType">
    </div>
    
    <div class="form-row">
        <label>&nbsp;</label>
        <input type="checkbox" id="node-input-validateInputMsg" style="display: inline-block; width: auto; vertical-align: top;">
        <label for="node-input-validateInputMsg" style="width:70%;"> Validate input messages</label>
    </div>


    
    </br>
    
    <div class="form-row">
        <label>&nbsp;</label>
        <button id="node-input-validate"><i class="fa fa-check-square-o"></i> Validate Plotly config</button>
        <button id="node-input-plotlyConfig"><i class="fa fa-eye" style="margin-left:10px;"></i> Show Plotly config</button>
    </div>
    
    </br>
    
    <div class="form-row">
        <!-- Tabsheets -->
        <ul style="background: #fff; min-width: 490px; margin-bottom: 20px;" id="node-plotly-tabs"></ul>
    </div>
    
    <div id="node-plotly-tabs-content" style="min-height: 150px">
    
        <!-- Tabsheet "Layout" -->
        <div id="node-plotly-tab-layout" class="node-plotly-tab-content" style="position: relative; margin-top: 30px;">
        
            <div class="form-row" style="margin-bottom:0;">
                <label for="node-input-trace"><i class="fa fa-th-large"></i> Layout</label>
            </div>
            
            <div class="form-row node-input-layout-container-row">
                <!-- Container element where the editableList of chart properties will be displayed -->
                <ol id="node-input-layout-container"></ol>
            </div>
         
        </div>       
    
        <!-- Tabsheet "Traces" -->
        <div id="node-plotly-tab-traces" class="node-plotly-tab-content" style="position: relative; margin-top: 30px;">
    
            <div class="form-row node-input-traces-container-row" style="margin-bottom:0;">
                <label><i class="fa fa-line-chart"></i> Traces:</label>
            </div>
            
            <div class="form-row node-input-traces-container-row">
                <!-- Container element where the editableList of traces will be displayed -->
                <ol id="node-input-traces-container"></ol>
            </div>
            
            <div class="form-tips"><b>CAUTION:</b> When an existing trace type is changed, the corresponding trace properties will be removed!</div>
        </div>
        
        <!-- Tabsheet "Properties" -->
        <div id="node-plotly-tab-traceproperties" class="node-plotly-tab-content" style="position: relative; margin-top: 30px;">
        
            <div class="form-row">
                <label for="node-input-trace"><i class="fa fa-line-chart"></i> Trace</label>
                <select id="node-input-trace">
                </select>
            </div>
            
            <br>
            
            <div class="form-row node-input-traces-container-row" style="margin-bottom:0;">
                <label><i class="fa fa-list"></i> Properties:</label>
            </div>
            
            <div class="form-row node-input-properties-container-row">
                <!-- Container element where the editableList of trace properties will be displayed -->
                <ol id="node-input-properties-container"></ol>
            </div>
            
            <div class="form-tips"><b>CAUTION:</b> When an existing property name is changed, the corresponding property value will be removed!</div>
        
        </div>
        
        <!-- Tabsheet "Arrays" -->
        <div id="node-plotly-tab-arrays" class="node-plotly-tab-content" style="position: relative; margin-top: 30px;">
    
            <div class="form-row node-input-arrays-container-row" style="margin-bottom:0;">
                <label><i class="fa fa-list-ol"></i> Arrays:</label>
            </div>
            
            <div class="form-row node-input-arrays-container-row">
                <!-- Container element where the editableList of arrays will be displayed -->
                <ol id="node-input-arrays-container"></ol>
            </div>
            
            <div class="form-tips"><b>CAUTION:</b> When an existing array type is changed, the corresponding array items will be removed!</div>
        </div>
        
        <!-- Tabsheet "Items" -->
        <div id="node-plotly-tab-arrayitems" class="node-plotly-tab-content" style="position: relative; margin-top: 30px;">
        
            <div class="form-row">
                <label for="node-input-array"><i class="fa fa-list-ol"></i> Array</label>
                <select id="node-input-array">
                </select>
            </div>
            
            <br>
            
            <div class="form-row node-input-items-container-row" style="margin-bottom:0;">
                <label><i class="fa fa-list"></i> Array items:</label>
            </div>
            
            <div class="form-row node-input-items-container-row">
                <!-- Container element where the editableList of array items will be displayed -->
                <ol id="node-input-items-container"></ol>
            </div>
        
        </div>
</script>

<script type="text/html" data-help-name="ui_plotly-chart">
    <p>A Node-RED dashboard ui node to display text with a defined color on the dashboard.</p>
    <p>Use this node as a template for building your own ui node.</p>
</script>
